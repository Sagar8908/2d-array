class Solution {
public:
    int solve(vector<vector<int>>& M) {
        int n = M.size();
        int m = M[0].size();
        const int MINF = INT_MIN;
        
        // Memoization map to cache results for each state
        unordered_map<string, int> memo;

        // Helper function to convert state to string for memoization
        auto key = [&](int x, int y, int dy) {
            return to_string(x) + "," + to_string(y) + "," + to_string(dy);
        };

        // Recursive DFS function with memoization
        function<int(int, int, int)> dfs = [&](int x, int y, int dy) {
            if (x == n) return 0;
            if (M[x][y] == 1) return MINF;
            string k = key(x, y, dy);
            if (memo.find(k) != memo.end()) return memo[k];

            int ans = dfs(x + 1, y, 0) + 1;
            if (dy == 0) {
                ans = max(ans, dfs(x, y, 1));
                ans = max(ans, dfs(x, y, -1));
            } else if (0 <= y + dy && y + dy < m) {
                ans = max(ans, dfs(x, y + dy, dy) + 1);
            }
            memo[k] = ans;
            return ans;
        };

        int result = 0;
        for (int y = 0; y < m; ++y) {
            result = max(result, dfs(0, y, 0));
        }
        return max(0, result);
    }
};
