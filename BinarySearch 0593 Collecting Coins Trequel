class Solution {
public:
    int solve(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        const int INF = INT_MIN;
        
        // Create a memoization table
        vector<vector<vector<vector<int>>>> dp(n, vector<vector<vector<int>>>(m, vector<vector<int>>(n, vector<int>(m, INF))));
        
        // Define the DFS function
        function<int(int, int, int, int)> dfs = [&](int x1, int y1, int x2, int y2) -> int {
            if (x1 == y1 && y1 == x2 && y2 == 0) {
                return (grid[0][0] != -1) ? grid[0][0] : INF;
            }
            if (x1 < 0 || x1 >= n || x2 < 0 || x2 >= n || y1 < 0 || y1 >= m || y2 < 0 || y2 >= m) {
                return INF;
            }
            if (grid[x1][y1] == -1 || grid[x2][y2] == -1) {
                return INF;
            }
            if (dp[x1][y1][x2][y2] != INF) {
                return dp[x1][y1][x2][y2];
            }
            
            int result = INF;
            for (const auto& [i1, j1] : vector<pair<int, int>>{{x1, y1 - 1}, {x1 - 1, y1}}) {
                for (const auto& [i2, j2] : vector<pair<int, int>>{{x2, y2 - 1}, {x2 - 1, y2}}) {
                    result = max(result, dfs(i1, j1, i2, j2));
                }
            }
            result += (grid[x1][y1] + grid[x2][y2]) / (1 + (x1 == x2));
            return dp[x1][y1][x2][y2] = result;
        };
        
        int res = dfs(n - 1, m - 1, n - 1, m - 1);
        return (res != INF) ? res : 0;
    }
};
